#include<stdio.h>
#include<stdlib.h>
//本文件为二叉树的构建与三种遍历方法基于C语言。

typedef struct BiTNode
{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;


void PreOrderTraverse(BiTree T)//二叉树的先序遍历
{
    if(T==NULL)
        return ;
    printf("%c ",T->data);
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}
void InOrderTraverse(BiTree T)//二叉树的中序遍历
{
   if(T==NULL)
       return ;
   InOrderTraverse(T->lchild);
    printf("%c ",T->data);
   InOrderTraverse(T->rchild);
}
void PostOrderTraverse(BiTree T)//后序遍历
{
    if(T==NULL)
        return;
    PostOrderTraverse(T->lchild);
    PostOrderTraverse(T->rchild);
    printf("%c ",T->data);
}

void LevelorderTraverse(BiTree T)//层序遍历
{
    if(T==NULL)
        return ;
    BiTree queueline[101],root;  
    //此处基础设定为100个，但是有需求再改，有能力用队列链表
    int front=0,rear=0;
    queueline[rear++] = T;

    while(front != rear)
    {
        root = queueline[rear--];
        printf(" %d",root->data);
        if(root->lchild) queueline[rear++] = root->lchild;
        if(root->rchild) queueline[rear++] = root->rchild;
    }

}

BiTree CreateBiTree(BiTree *T)//此为中序创建法
{
    char ch;
    scanf("%c",&ch);
    if(ch==' ')
        return NULL;
    else
    {
        *T=(BiTree  )malloc(sizeof(BiTNode));
        if(!*T)
            exit(-1);
        (*T)->data=ch;
        (*T)->lchild = CreateBiTree(&(*T)->lchild);
        (*T)->rchild = CreateBiTree(&(*T)->rchild);
    }
    return *T;
}
int main()
{
    BiTree T;
    T = CreateBiTree(&T);
    PreOrderTraverse (T);
    InOrderTraverse(T);
    PostOrderTraverse(T);
    LevelorderTraverse(T);
    return 0;
}

