#include<stdio.h>
#include<time.h>

#define X 8
#define Y 8

int chess[X][Y];

int nextxy(int *x,int *y,int count)//用来找（x，y）位置下一个可走的位置
{
    switch(count)
    {
    case 0:
        if( *x+2<=X-1 && *y-1>=0 && chess[*x+2,*y-1]==0)
        {
            *x +=2; *y -=1;
            return 1;
        }
        break;

    case 1:
        if( *x+2<=X-1 && *y+1>=0 && chess[*x+2,*y+1]==0)
        {
            *x +=2; *y +=1;
            return 1;
        }
        break;

    case 2:
        if( *x+1<=X-1 && *y-2>=0 && chess[*x+1,*y-2]==0)
        {
            *x +=1; *y -=2;
            return 1;
        }
        break;

    case 3:
        if( *x+1<=X-1 && *y+2>=0 && chess[*x+1,*y+2]==0)
        {
            *x +=1; *y +=2;
            return 1;
        }
        break;

    case 4:
        if( *x-2<=X-1 && *y-1>=0 && chess[*x-2,*y-1]==0)
        {
            *x -=2; *y -=1;
            return 1;
        }
        break;

    case 5:
        if( *x-2<=X-1 && *y+1>=0 && chess[*x-2,*y+1]==0)
        {
            *x -=2; *y +=1;
            return 1;
        }
        break;

    case 6:
        if( *x-1<=X-1 && *y-2>=0 && chess[*x-1,*y-2]==0)
        {
            *x -=1; *y -=2;
            return 1;
        }
        break;

    case 7:
        if( *x-1<=X-1 && *y+2>=0 && chess[*x-1,*y+2]==0)
        {
            *x -=1; *y +=2;
            return 1;
        }
        break;

    default:
        break;
    }
    return 0;
}

void print()
{
    int i,j;
    for(i=0;i<X;i++)
    {
        for(j=0;j<Y;j++)
            printf("%2d\t",chess[i][j]);
        printf("\n");
    }
    printf("\n");
}
//深度优先遍历棋盘算法
//（x,y）为位置坐标
//tag是标记变量，每走一步，tag+1
int TravelChessBoard(int x,int y,int tag)
{
    int x1=x,y1=y,count=0;
    chess[x][y] = tag;

    if( X*Y==tag)
    {
        print();
        return 1;
    }

    //找到马的下一个坐标，找到flag==1，否则0
    flag = nextxy(&x1,&x2,count);//count用来确定找的位置
    while(flag==0 && count<7)
    {
        count++;
        flag = nextxy(&x1,&y1,count);//找遍八个位置看有没有行的
    }


    while(flag)
    {
        if( TravelChessBoard(x1,y1,tag+1))
        {
            return 1;
        }

        //失败了就死了，要回上一个继续找，找马下一步可走的坐标
        x1 = x;
        y1 = y;
        count++;//既然下一个不能再下一个，我就回来选另一个下一个

        flag = nextxy(&x1,&x2,count);//count用来确定找的位置
        while(flag==0 && count<7)
        {
            count++;
            flag = nextxy(&x1,&y1,count);//找遍八个位置看有没有行的
        }

    }

    if(flag==0)
    {
        chess[x][y] = 0;
    }

    return 0;
}

int main()
{
    int i,j;
    clock_t start,finish;

    start = clock();

    for(i=0;i<X;i++)
    {
        for(j=0;j<Y;j++)
            chess[i][j]=0;
    }

    if( !TravelChessBoard(2,0,1))
    {
        printf("遍历失败\n");
    }
    finish = clock();
    printf("\n用时:%f秒\n\n",(double)(finish-start)/CLOCKS_PER_SEC);
    return 0;
}
